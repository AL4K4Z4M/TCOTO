<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamer.bot Tetris</title>
    <!-- Google Fonts: Barlow SemiBold & Press Start 2P (Retro) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@600&family=Press+Start+2P&display=swap" rel="stylesheet">
    <!-- Streamer.bot Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 1920px;
            height: 1080px;
            overflow: hidden;
            background-color: transparent; 
            font-family: 'Barlow', sans-serif;
        }

        /* Full Screen Canvas */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Layer (Above Canvas) */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 0;
            width: 1920px;
            pointer-events: none;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
        }

        /* Stats Styling */
        .stat-line {
            font-family: 'Barlow', sans-serif;
            font-weight: 800;
            font-size: 2rem;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            text-transform: uppercase;
        }

        #last-follower-display {
            color: #FFD700; /* Gold */
        }

        /* Connection Status */
        #connection-dot {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 15px;
            height: 15px;
            background-color: red;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 10px black;
            z-index: 100;
        }

        /* Debug Button */
        #debug-spawn-btn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-family: sans-serif;
            font-weight: bold;
            cursor: pointer;
            z-index: 101;
            pointer-events: auto;
        }
        #debug-spawn-btn:hover { background: #0056b3; }
    </style>
</head>
<body>

    <canvas id="tetris" width="1920" height="1080"></canvas>

    <script>
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        
        // Dimensions
        const BLOCK_SIZE = 60; 
        const COLS = 32; 
        const ROWS = 18; 
        
        const BOARD_WIDTH = COLS * BLOCK_SIZE; 
        const BOARD_HEIGHT = ROWS * BLOCK_SIZE; 
        const OFFSET_X = 0; 
        const OFFSET_Y = 0; 

        const PIECES = {
            'I': [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
            'J': [[1,0,0], [1,1,1], [0,0,0]],
            'L': [[0,0,1], [1,1,1], [0,0,0]],
            'O': [[1,1], [1,1]],
            'S': [[0,1,1], [1,1,0], [0,0,0]],
            'Z': [[1,1,0], [0,1,1], [0,0,0]],
            'T': [[0,1,0], [1,1,1], [0,0,0]]
        };

        const COLORS = {
            'I': '#00f0f0', 'J': '#0000f0', 'L': '#f0a000', 
            'O': '#f0f000', 'S': '#00f000', 'T': '#a000f0', 
            'Z': '#f00000'
        };

        // --- 2. GAME STATE ---
        let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        let followerQueue = [];
        let activePiece = null;
        let lastDropTime = 0;
        let dropInterval = 1000; 
        let sessionFollowCount = 0;

        // --- 3. RENDERING ENGINE ---

        function getWrappedLines(ctx, text, maxWidth) {
            if (ctx.measureText(text).width <= maxWidth) return [text];
            let lines = [], currentLine = "";
            const chars = text.includes(' ') ? text.split(' ') : text; 
            
            if (text.includes(' ')) {
                currentLine = chars[0];
                for(let i=1; i<chars.length; i++) {
                    if (ctx.measureText(currentLine + " " + chars[i]).width < maxWidth) currentLine += " " + chars[i];
                    else { lines.push(currentLine); currentLine = chars[i]; }
                }
                lines.push(currentLine);
            } else {
                for(let char of text) {
                    if (ctx.measureText(currentLine + char).width < maxWidth) currentLine += char;
                    else { lines.push(currentLine); currentLine = char; }
                }
                lines.push(currentLine);
            }
            return lines;
        }

        function drawBlock(x, y, color) {
            const drawX = OFFSET_X + (x * BLOCK_SIZE);
            const drawY = OFFSET_Y + (y * BLOCK_SIZE);

            context.fillStyle = color;
            context.fillRect(drawX, drawY, BLOCK_SIZE, BLOCK_SIZE);
            
            // Highlight
            context.fillStyle = 'rgba(255,255,255,0.4)';
            context.fillRect(drawX, drawY, BLOCK_SIZE, 8);
            context.fillRect(drawX, drawY, 8, BLOCK_SIZE);

            // Light Inner Grid
            context.strokeStyle = 'rgba(0,0,0,0.3)';
            context.lineWidth = 1;
            context.strokeRect(drawX, drawY, BLOCK_SIZE, BLOCK_SIZE);
        }

        function drawBoard() {
            context.clearRect(0, 0, canvas.width, canvas.height);

            // Pass 1: Draw Base Blocks
            board.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell !== 0) {
                        drawBlock(x, y, COLORS[cell.type]);
                    }
                });
            });

            // Pass 2: Draw Thick Outlines
            context.strokeStyle = 'black';
            context.lineWidth = 5;
            context.lineCap = 'square';

            board.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell !== 0) {
                        const px = OFFSET_X + (x * BLOCK_SIZE);
                        const py = OFFSET_Y + (y * BLOCK_SIZE);
                        const bs = BLOCK_SIZE;

                        if (y === 0 || !board[y-1][x] || board[y-1][x].username !== cell.username) {
                            context.beginPath(); context.moveTo(px, py); context.lineTo(px + bs, py); context.stroke();
                        }
                        if (y === ROWS - 1 || !board[y+1][x] || board[y+1][x].username !== cell.username) {
                            context.beginPath(); context.moveTo(px, py + bs); context.lineTo(px + bs, py + bs); context.stroke();
                        }
                        if (x === 0 || !board[y][x-1] || board[y][x-1].username !== cell.username) {
                            context.beginPath(); context.moveTo(px, py); context.lineTo(px, py + bs); context.stroke();
                        }
                        if (x === COLS - 1 || !board[y][x+1] || board[y][x+1].username !== cell.username) {
                            context.beginPath(); context.moveTo(px + bs, py); context.lineTo(px + bs, py + bs); context.stroke();
                        }
                    }
                });
            });

            // Pass 3: Draw Names
            context.textAlign = "center";
            context.textBaseline = "middle";
            context.shadowColor = "black";
            context.shadowBlur = 3;
            context.shadowOffsetX = 1;
            context.shadowOffsetY = 1;
            context.fillStyle = "white";

            board.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell !== 0 && cell.isAnchor && cell.username) {
                        const centerX = OFFSET_X + (x * BLOCK_SIZE) + (BLOCK_SIZE / 2);
                        const centerY = OFFSET_Y + (y * BLOCK_SIZE) + (BLOCK_SIZE / 2);
                        const maxW = BLOCK_SIZE - 4; 

                        let fontSize = 16;
                        let lines = [];
                        let lineHeight = fontSize;

                        do {
                            fontSize--;
                            context.font = "bold " + fontSize + "px 'Barlow'";
                            lineHeight = fontSize; 
                            lines = getWrappedLines(context, cell.username, maxW);
                            if ((lines.length * lineHeight) < (BLOCK_SIZE - 4)) break;
                        } while (fontSize > 10);

                        const totalHeight = lines.length * lineHeight;
                        let startY = centerY - (totalHeight / 2) + (lineHeight / 2);

                        lines.forEach((line, i) => {
                             context.fillText(line, centerX, startY + (i * lineHeight));
                        });
                    }
                });
            });
            context.shadowColor = "transparent";
            context.textBaseline = "alphabetic"; 
        }

        function drawActivePiece() {
            if (!activePiece) return;

            // Pass 1: Fill
            activePiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(activePiece.x + x, activePiece.y + y, COLORS[activePiece.type]);
                    }
                });
            });

            // Pass 2: Outline
            context.strokeStyle = 'black';
            context.lineWidth = 5;
            context.lineCap = 'square';

            activePiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const px = OFFSET_X + (activePiece.x+x)*BLOCK_SIZE;
                        const py = OFFSET_Y + (activePiece.y+y)*BLOCK_SIZE;
                        const bs = BLOCK_SIZE;

                        if (y===0 || activePiece.shape[y-1][x]===0) { context.beginPath(); context.moveTo(px,py); context.lineTo(px+bs,py); context.stroke(); }
                        if (y===activePiece.shape.length-1 || activePiece.shape[y+1][x]===0) { context.beginPath(); context.moveTo(px,py+bs); context.lineTo(px+bs,py+bs); context.stroke(); }
                        if (x===0 || activePiece.shape[y][x-1]===0) { context.beginPath(); context.moveTo(px,py); context.lineTo(px,py+bs); context.stroke(); }
                        if (x===row.length-1 || activePiece.shape[y][x+1]===0) { context.beginPath(); context.moveTo(px+bs,py); context.lineTo(px+bs,py+bs); context.stroke(); }
                    }
                });
            });

            // Pass 3: Floating Name
            if (activePiece.username) {
                const px = OFFSET_X + (activePiece.x*BLOCK_SIZE);
                const py = OFFSET_Y + (activePiece.y*BLOCK_SIZE);
                const w = activePiece.shape[0].length * BLOCK_SIZE;
                const cx = px + (w/2);
                const ty = py - 15;

                context.fillStyle = "white";
                context.font = "bold 32px 'Barlow'"; 
                context.textAlign = "center";
                context.shadowColor = "black";
                context.shadowBlur = 4;
                context.shadowOffsetX = 2;
                context.shadowOffsetY = 2;
                
                context.fillText(activePiece.username, cx, ty);
                context.shadowColor = "transparent";
            }
        }

        // --- 4. GAME LOGIC ---

        function collide(board, piece) {
            const m = piece.shape;
            const o = piece;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                       (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        function merge(board, piece) {
            let blocks = [];
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        blocks.push({x: x, y: y});
                    }
                });
            });

            let anchorIndex = Math.floor(blocks.length / 2);
            let anchor = blocks[anchorIndex];

            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        let isAnchorBlock = (x === anchor.x && y === anchor.y);
                        board[y + piece.y][x + piece.x] = {
                            type: piece.type,
                            username: piece.username,
                            isAnchor: isAnchorBlock
                        };
                    }
                });
            });
        }

        function rotate(matrix) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            matrix.forEach(row => row.reverse());
        }

        function arenaSweep() {
            outer: for (let y = board.length -1; y > 0; --y) {
                for (let x = 0; x < board[y].length; ++x) {
                    if (board[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                ++y;
            }
        }

        function resetGame() {
            board.forEach(row => row.fill(0));
        }

        function spawnPiece() {
            if (followerQueue.length === 0) {
                return;
            }

            const follower = followerQueue.shift();

            const types = 'ILJOTSZ';
            const type = types[types.length * Math.random() | 0];
            
            activePiece = {
                shape: PIECES[type],
                type: type,
                x: (COLS / 2 | 0) - (PIECES[type][0].length / 2 | 0),
                y: 0,
                username: follower
            };

            if (collide(board, activePiece)) {
                resetGame();
            }
        }

        function drop() {
            if (!activePiece) {
                if (followerQueue.length > 0) spawnPiece();
                return;
            }

            activePiece.y++;
            if (collide(board, activePiece)) {
                activePiece.y--;
                merge(board, activePiece);
                activePiece = null;
                arenaSweep();
                spawnPiece(); 
            }
            lastDropTime = Date.now();
        }

        function update() {
            const now = Date.now();
            if (now - lastDropTime > dropInterval) {
                drop();
            }
            drawBoard();
            drawActivePiece();
            requestAnimationFrame(update);
        }

        update();

        // --- 5. CONTROLS ---
        function playerMove(dir) {
            if (!activePiece) return;
            activePiece.x += dir;
            if (collide(board, activePiece)) {
                activePiece.x -= dir;
            }
        }

        function playerRotate(dir) {
            if (!activePiece) return;
            const pos = activePiece.x;
            let offset = 1;
            rotate(activePiece.shape);
            while (collide(board, activePiece)) {
                activePiece.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > activePiece.shape[0].length) {
                    rotate(activePiece.shape);
                    activePiece.x = pos;
                    return;
                }
            }
        }

        function playerDrop() {
            if (!activePiece) return;
            activePiece.y++;
            if (collide(board, activePiece)) {
                activePiece.y--;
                lastDropTime = 0;
            }
            lastDropTime = 0;
        }

        // --- KEYBOARD LISTENER (DEBUGGING) ---
        document.addEventListener('keydown', event => {
            if (event.key === 'ArrowLeft') playerMove(-1);
            if (event.key === 'ArrowRight') playerMove(1);
            if (event.key === 'ArrowDown') playerDrop();
            if (event.key === 'ArrowUp') playerRotate();
            if (event.key === 't') testTetris();
        });

        // --- 6. STREAMER.BOT CONNECTION ---
        const connDot = document.getElementById('connection-dot');
        
        const client = new StreamerbotClient({
            host: '127.0.0.1',
            port: 8080,
            endpoint: '/',
            autoReconnect: true
        });

        client.on('Connect', () => {
            console.log('Connected');
            connDot.style.backgroundColor = 'lime';
            client.subscribe({ "Twitch": ["Follow"], "General": ["Custom"] });
        });
        
        client.on('Disconnect', () => {
            connDot.style.backgroundColor = 'red';
        });

        client.on('Twitch.Follow', (payload) => {
            let name = payload.data?.user_name || payload.data?.user?.name || "Follower";
            console.log("New Follower:", name);
            followerQueue.push(name);
            
            // UPDATE STATS
            sessionFollowCount++;
            document.getElementById('follower-count-display').innerText = "New Twitch followers this stream: " + sessionFollowCount;
            document.getElementById('last-follower-display').innerText = "Last Follower: " + name;

            if (!activePiece) spawnPiece();
        });

        // --- EVENT LISTENER (FIXED: PERMISSIVE & SINGLE) ---
        client.on('General.Custom', (payload) => {
            // Convert the entire payload to a string to catch any format
            const raw = JSON.stringify(payload);

            if (raw.includes("TetrisLeft")) playerMove(-1);
            if (raw.includes("TetrisRight")) playerMove(1);
            if (raw.includes("TetrisRotate")) playerRotate();
            if (raw.includes("TetrisDown")) playerDrop();
            
            if (raw.includes("TetrisTest")) testTetris();
        });

        window.testTetris = () => {
            const longName = "LongUser_" + (Math.floor(Math.random() * 900) + 100) + "_TTV";
            followerQueue.push(longName);
            
            // Update stats for test
            sessionFollowCount++;
            document.getElementById('follower-count-display').innerText = "New Twitch followers this stream: " + sessionFollowCount;
            document.getElementById('last-follower-display').innerText = "Last Follower: " + longName;

            if(!activePiece) spawnPiece();
        }

    </script>
</body>
</html>