<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamer.bot Ducks & Toasters</title>
    <!-- Google Fonts: Barlow SemiBold -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@600&display=swap" rel="stylesheet">
    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Streamer.bot Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: transparent;
            font-family: "Barlow", sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Debug & Status Overlay */
        #status-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
        }

        .status-msg {
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            max-width: 400px;
        }
        .status-error { color: #ff5555; }
        .status-warn { color: #ffff55; }

        /* Click to Start Overlay */
        #click-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            cursor: pointer;
            transition: opacity 0.3s;
        }
        #click-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .click-btn {
            background: white;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 24px;
            font-weight: 800;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>

    <div id="status-overlay">
        <div class="status-msg">Initializing...</div>
    </div>

    <div id="click-overlay" onclick="enableAudio()">
        <div class="click-btn">CLICK TO ENABLE AUDIO ðŸ”Š</div>
    </div>

    <script>
        (function() {
            // --- LOGGER ---
            function log(msg, type='info') {
                const el = document.getElementById('status-overlay');
                const line = document.createElement('div');
                line.className = 'status-msg';
                if (type === 'error') line.classList.add('status-error');
                if (type === 'warn') line.classList.add('status-warn');
                line.innerText = msg;
                el.appendChild(line);

                // Keep only last 10 lines
                while (el.children.length > 10) el.removeChild(el.firstChild);
                console.log(`[Ducks] ${msg}`);
            }

            // --- AUDIO CONTEXT SETUP (Web Audio API) ---
            var AudioContext = window.AudioContext || window.webkitAudioContext;
            var audioCtx = new AudioContext();

            // --- ASSET LOADER ---
            const ASSETS = {};
            const ASSET_PATHS = [
                'assets/',       // Try relative to page first (pages/assets/)
                '../assets/'     // Try relative to root (assets/)
            ];

            function loadAudioBuffer(key, filename) {
                return new Promise((resolve, reject) => {
                    let attempt = 0;

                    function tryLoad() {
                        if (attempt >= ASSET_PATHS.length) {
                            log(`Failed to load ${filename}`, 'error');
                            ASSETS[key] = null; // Mark as failed
                            resolve(null);
                            return;
                        }

                        const path = ASSET_PATHS[attempt] + filename;

                        fetch(path)
                            .then(response => {
                                if (!response.ok) throw new Error(response.statusText);
                                return response.arrayBuffer();
                            })
                            .then(buffer => audioCtx.decodeAudioData(buffer))
                            .then(decodedData => {
                                log(`Loaded & Decoded: ${filename}`, 'info');
                                ASSETS[key] = decodedData;
                                resolve(decodedData);
                            })
                            .catch(e => {
                                // log(`Failed path: ${path} (${e.message})`, 'warn');
                                attempt++;
                                tryLoad();
                            });
                    }
                    tryLoad();
                });
            }

            function loadImagePath(filename) {
                return new Promise((resolve) => {
                    let attempt = 0;
                    function tryLoad() {
                        if (attempt >= ASSET_PATHS.length) {
                            log(`Failed to load image ${filename}`, 'error');
                            resolve(null);
                            return;
                        }
                        const path = ASSET_PATHS[attempt] + filename;
                        const img = new Image();
                        img.onload = () => resolve(path);
                        img.onerror = () => { attempt++; tryLoad(); };
                        img.src = path;
                    }
                    tryLoad();
                });
            }

            // Preload All
            const loaders = [];
            loaders.push(loadAudioBuffer('toaster', 'toaster.wav'));
            for(let i=1; i<=6; i++) loaders.push(loadAudioBuffer(`duck${i}`, `duck${i}.wav`));

            // Image paths resolved
            let duckTexturePath = '../assets/Rubber_Duck.png'; // Default fallback
            let toasterTexturePath = '../assets/Toaster.png';

            loaders.push(loadImagePath('Rubber_Duck.png').then(p => { if(p) duckTexturePath = p; }));
            loaders.push(loadImagePath('Toaster.png').then(p => { if(p) toasterTexturePath = p; }));

            Promise.all(loaders).then(() => {
                log("Assets Loading Complete");
            });

            // --- AUDIO CONTROL ---
            window.enableAudio = function() {
                const overlay = document.getElementById('click-overlay');
                overlay.classList.add('hidden');

                // Resume Context
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume().then(() => {
                        log("Audio Context Resumed");
                    });
                } else {
                    log("Audio Context Running");
                }
            };

            function playSound(type) {
                // Ensure context is running
                if (audioCtx.state === 'suspended') {
                    document.getElementById('click-overlay').classList.remove('hidden');
                    return; // Can't play yet
                }

                let buffer = null;
                if (type === 'toaster') {
                    buffer = ASSETS['toaster'];
                } else if (type === 'duck') {
                    // Pick random valid duck sound
                    const available = [];
                    for(let i=1; i<=6; i++) if (ASSETS[`duck${i}`]) available.push(ASSETS[`duck${i}`]);

                    if (available.length > 0) {
                        buffer = available[Math.floor(Math.random() * available.length)];
                    }
                }

                if (buffer) {
                    try {
                        const source = audioCtx.createBufferSource();
                        source.buffer = buffer;

                        // Gain Node for Volume
                        const gain = audioCtx.createGain();
                        gain.gain.value = 0.5; // Prevent ear blast

                        source.connect(gain);
                        gain.connect(audioCtx.destination);

                        source.start(0);
                    } catch(e) {
                        log(`Play Error: ${e.message}`, 'error');
                    }
                }
            }

            // --- PHYSICS ENGINE SETUP ---
            const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
                  Bodies = Matter.Bodies, Body = Matter.Body, Composite = Matter.Composite,
                  Events = Matter.Events, Vector = Matter.Vector, Sleeping = Matter.Sleeping;

            const engine = Engine.create({ positionIterations: 20, velocityIterations: 20, enableSleeping: true });

            window.engine = engine;

            const render = Render.create({
                element: document.body,
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    pixelRatio: 1,
                    background: 'transparent',
                    wireframes: false,
                    showAngleIndicator: false
                }
            });

            // --- ENVIRONMENT ---
            const wallOpts = { isStatic: true, render: { visible: false } };
            const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight + 100, window.innerWidth, 200, wallOpts);
            const leftWall = Bodies.rectangle(-100, window.innerHeight/2, 200, window.innerHeight * 5, wallOpts);
            const rightWall = Bodies.rectangle(window.innerWidth + 100, window.innerHeight/2, 200, window.innerHeight * 5, wallOpts);
            const ceiling = Bodies.rectangle(window.innerWidth/2, -500, window.innerWidth, 200, wallOpts);

            Composite.add(engine.world, [ground, leftWall, rightWall, ceiling]);

            // --- FLUSH ---
            var isPitOpen = false;
            function openPit() {
                if (isPitOpen) return;
                isPitOpen = true;
                Composite.remove(engine.world, ground);

                Composite.allBodies(engine.world).forEach(body => {
                    if (!body.isStatic) {
                        Sleeping.set(body, false);
                        Body.setVelocity(body, { x: 0, y: 0 });
                        Body.setVelocity(body, { x: (Math.random() - 0.5) * 5, y: 15 });
                    }
                });

                setTimeout(() => {
                    Body.setPosition(ground, { x: window.innerWidth / 2, y: window.innerHeight + 100 });
                    Body.setVelocity(ground, { x: 0, y: 0 });
                    Composite.add(engine.world, ground);
                    isPitOpen = false;
                }, 5000);
            }

            // Garbage Collector
            setInterval(() => {
                const bodies = Composite.allBodies(engine.world);
                bodies.forEach(body => {
                    if (body.position.y > window.innerHeight + 2000) Composite.remove(engine.world, body);
                });
            }, 2000);

            // --- RENDER TEXT ---
            Events.on(render, 'afterRender', function() {
                const context = render.context;
                const bodies = Composite.allBodies(engine.world);
                context.textAlign = 'center';
                context.textBaseline = 'middle';

                for (let i = 0; i < bodies.length; i += 1) {
                    const body = bodies[i];
                    if (body.username) {
                        const dim = body.visualSize || 35;
                        const mainSize = Math.max(12, dim * 0.5);

                        context.font = `800 ${mainSize}px "Barlow", Arial, sans-serif`;
                        context.lineWidth = 3;
                        context.strokeStyle = `black`;
                        context.fillStyle = `white`;

                        context.save();
                        context.translate(body.position.x, body.position.y);
                        context.rotate(body.angle);
                        context.strokeText(body.username, 0, 0);
                        context.fillText(body.username, 0, 0);
                        context.restore();
                    }
                }
            });

            // --- COLLISION ---
            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach((pair) => {
                    const bodyA = pair.bodyA;
                    const bodyB = pair.bodyB;

                    if (bodyA.isStatic || bodyB.isStatic) return;

                    const speedA = bodyA.speed;
                    const speedB = bodyB.speed;
                    const impact = speedA + speedB;

                    if (impact > 2.0) {
                        // Sound
                        if (bodyA.bodyType === 'duck' || bodyB.bodyType === 'duck') {
                             if (Math.random() < 0.3) playSound('duck');
                        }
                        if (bodyA.bodyType === 'toaster' || bodyB.bodyType === 'toaster') {
                             if (Math.random() < 0.3) playSound('toaster');
                        }

                        // Shockwave (Toaster)
                        const handleShockwave = (originBody) => {
                            if (originBody.bodyType !== 'toaster') return;
                            if (impact < 5.0) return;

                            const center = originBody.position;
                            const range = 250;
                            const forceMag = 0.1 * (impact / 10);

                            Composite.allBodies(engine.world).forEach(b => {
                                if (b === originBody || b.isStatic) return;
                                const dist = Vector.magnitude(Vector.sub(b.position, center));
                                if (dist < range) {
                                    const dir = Vector.normalise(Vector.sub(b.position, center));
                                    Body.applyForce(b, b.position, Vector.mult(dir, forceMag));
                                }
                            });
                        };

                        handleShockwave(bodyA);
                        handleShockwave(bodyB);
                    }
                });
            });

            // --- SPAWN LOGIC ---
            function createDuck(x, y, username) {
                // Size: 0.8x to 1.3x
                const scaleMult = 0.8 + Math.random() * 0.5;
                const baseSize = 50;
                const size = baseSize * scaleMult;

                const body = Bodies.circle(x, y, size/2, {
                    restitution: 0.9,
                    density: 0.001,
                    friction: 0.05,
                    render: {
                        sprite: {
                            texture: duckTexturePath, // Resolved path
                            xScale: (size / 512),
                            yScale: (size / 512)
                        }
                    }
                });

                body.username = username;
                body.bodyType = 'duck';
                body.visualSize = size;
                return body;
            }

            function createToaster(x, y, username) {
                // Size: 0.8x to 1.5x
                const scaleMult = 0.8 + Math.random() * 0.7;

                const baseWidth = 70;
                const baseHeight = 50;

                const width = baseWidth * scaleMult;
                const height = baseHeight * scaleMult;

                const body = Bodies.rectangle(x, y, width, height, {
                    restitution: 0.1,
                    density: 0.05, // Heavy
                    friction: 0.5,
                    render: {
                        sprite: {
                            texture: toasterTexturePath, // Resolved path
                            xScale: width / 500,
                            yScale: height / 500
                        }
                    }
                });

                body.render.sprite.xScale = (width * 1.5) / 500;
                body.render.sprite.yScale = (height * 1.5) / 500;

                body.username = username;
                body.bodyType = 'toaster';
                body.visualSize = width;
                return body;
            }

            function spawnEvent(username) {
                const x = Math.random() * (window.innerWidth - 100) + 50;
                const y = -100;

                const isDuck = Math.random() < 0.5;
                let body;

                if (isDuck) {
                    body = createDuck(x, y, username);
                } else {
                    body = createToaster(x, y, username);
                }

                Composite.add(engine.world, body);
            }

            // --- RUNNER ---
            var runner = Runner.create();
            Runner.run(runner, engine);
            Render.run(render);

            // --- SB CONNECTION ---
            var client = new StreamerbotClient({
                host: '127.0.0.1',
                port: 8080,
                endpoint: '/',
                autoReconnect: true
            });

            client.on('Connect', () => {
                log('SB Connected');
                client.subscribe({ "Twitch": ["Follow", "Subscription", "Cheer", "GiftSub", "ReSubscribe"] });
            });

            function getName(payload) {
                const d = payload.data || payload;
                return d.user_name || d.user || d.displayName || "User";
            }

            client.on('Twitch.Follow', (p) => spawnEvent(getName(p)));
            client.on('Twitch.Subscription', (p) => spawnEvent(getName(p)));
            client.on('Twitch.ReSubscribe', (p) => spawnEvent(getName(p)));
            client.on('Twitch.GiftSubscription', (p) => spawnEvent(getName(p)));
            client.on('Twitch.Cheer', (p) => spawnEvent(getName(p)));

            window.spawnEvent = spawnEvent;
            window.openPit = openPit;

        })();
    </script>
</body>
</html>