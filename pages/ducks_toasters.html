<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamer.bot Ducks & Toasters</title>
    <!-- Google Fonts: Barlow SemiBold -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@600&display=swap" rel="stylesheet">
    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Streamer.bot Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* Transparent background for OBS */
            background-color: transparent;
            font-family: "Barlow", sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

    <script>
        (function() {
            // --- 0. ASSET PRELOADING ---
            // Audio - Using ../assets/ based on ballpit example
            // We use ../assets/ because this file is in pages/ and assets is likely in root/assets/
            const soundToaster = new Audio('../assets/toaster.wav');
            soundToaster.addEventListener('error', (e) => console.error("Error loading toaster.wav. Check if file exists at ../assets/toaster.wav", e));

            const soundDucks = [];
            for(let i=1; i<=6; i++) {
                const s = new Audio(`../assets/duck${i}.wav`);
                s.addEventListener('error', (e) => console.error(`Error loading duck${i}.wav`, e));
                soundDucks.push(s);
            }

            // --- 1. PHYSICS ENGINE SETUP ---
            const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
                  Bodies = Matter.Bodies, Body = Matter.Body, Composite = Matter.Composite,
                  Events = Matter.Events, Vector = Matter.Vector, Sleeping = Matter.Sleeping;

            const engine = Engine.create({ positionIterations: 20, velocityIterations: 20, enableSleeping: true });

            // Expose engine for debugging/verification
            window.engine = engine;

            const render = Render.create({
                element: document.body,
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    pixelRatio: 1,
                    background: 'transparent',
                    wireframes: false,
                    showAngleIndicator: false
                }
            });

            // --- ENVIRONMENT SETUP ---
            const wallOpts = { isStatic: true, render: { visible: false } };
            const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight + 100, window.innerWidth, 200, wallOpts);
            const leftWall = Bodies.rectangle(-100, window.innerHeight/2, 200, window.innerHeight * 5, wallOpts);
            const rightWall = Bodies.rectangle(window.innerWidth + 100, window.innerHeight/2, 200, window.innerHeight * 5, wallOpts);
            // CEILING at -500 to keep balls inside but allow drop
            const ceiling = Bodies.rectangle(window.innerWidth/2, -500, window.innerWidth, 200, wallOpts);

            Composite.add(engine.world, [ground, leftWall, rightWall, ceiling]);

            // --- FLUSH MECHANIC ---
            var isPitOpen = false;
            function openPit() {
                if (isPitOpen) return;
                isPitOpen = true;
                Composite.remove(engine.world, ground);

                Composite.allBodies(engine.world).forEach(body => {
                    if (!body.isStatic) {
                        Sleeping.set(body, false);
                        Body.setVelocity(body, { x: 0, y: 0 });
                        Body.setVelocity(body, { x: (Math.random() - 0.5) * 5, y: 15 });
                    }
                });

                setTimeout(() => {
                    Body.setPosition(ground, { x: window.innerWidth / 2, y: window.innerHeight + 100 });
                    Body.setVelocity(ground, { x: 0, y: 0 });
                    Composite.add(engine.world, ground);
                    isPitOpen = false;
                }, 5000);
            }

            // Garbage Collector
            setInterval(() => {
                const bodies = Composite.allBodies(engine.world);
                bodies.forEach(body => {
                    if (body.position.y > window.innerHeight + 2000) Composite.remove(engine.world, body);
                });
            }, 2000);

            // --- CUSTOM RENDERER FOR TEXT ---
            Events.on(render, 'afterRender', function() {
                const context = render.context;
                const bodies = Composite.allBodies(engine.world);
                context.textAlign = 'center';
                context.textBaseline = 'middle';

                for (let i = 0; i < bodies.length; i += 1) {
                    const body = bodies[i];
                    if (body.username) {
                        // Use visual size for text scaling
                        const dim = body.visualSize || 35;

                        const mainSize = Math.max(12, dim * 0.5);

                        context.font = `800 ${mainSize}px "Barlow", Arial, sans-serif`;
                        context.lineWidth = 3;
                        context.strokeStyle = `black`;
                        context.fillStyle = `white`;

                        // Save context to rotate text with body
                        context.save();
                        context.translate(body.position.x, body.position.y);
                        context.rotate(body.angle);

                        context.strokeText(body.username, 0, 0);
                        context.fillText(body.username, 0, 0);

                        context.restore();
                    }
                }
            });

            // --- SOUND & COLLISION LOGIC ---

            function playSound(type) {
                try {
                    if (type === 'toaster') {
                         soundToaster.cloneNode(true).play().catch(e => console.warn("Audio play failed:", e));
                    } else if (type === 'duck') {
                        const idx = Math.floor(Math.random() * soundDucks.length);
                        soundDucks[idx].cloneNode(true).play().catch(e => console.warn("Audio play failed:", e));
                    }
                } catch(e) {
                    console.error("Audio Context Error:", e);
                }
            }

            // Resume audio context on click (just in case)
            window.addEventListener('click', () => {
                // Dummy play to unlock audio if needed
                soundToaster.play().then(() => soundToaster.pause()).catch(() => {});
            });

            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach((pair) => {
                    const bodyA = pair.bodyA;
                    const bodyB = pair.bodyB;

                    if (bodyA.isStatic || bodyB.isStatic) return;

                    const speedA = bodyA.speed;
                    const speedB = bodyB.speed;
                    const impact = speedA + speedB;

                    // Min impact to trigger sound/effects
                    if (impact > 2.0) {

                        // Handle Sound
                        if (bodyA.bodyType === 'duck' || bodyB.bodyType === 'duck') {
                             if (Math.random() < 0.3) playSound('duck');
                        }
                        if (bodyA.bodyType === 'toaster' || bodyB.bodyType === 'toaster') {
                             if (Math.random() < 0.3) playSound('toaster');
                        }

                        // Handle Shockwave (Toaster only)
                        const handleShockwave = (originBody) => {
                            if (originBody.bodyType !== 'toaster') return;
                            // Only trigger shockwave on heavy impacts
                            if (impact < 5.0) return;

                            const center = originBody.position;
                            const range = 250;
                            const forceMag = 0.1 * (impact / 10); // Scale with impact

                            Composite.allBodies(engine.world).forEach(b => {
                                if (b === originBody || b.isStatic) return;
                                const dist = Vector.magnitude(Vector.sub(b.position, center));
                                if (dist < range) {
                                    const dir = Vector.normalise(Vector.sub(b.position, center));
                                    Body.applyForce(b, b.position, Vector.mult(dir, forceMag));
                                }
                            });
                        };

                        handleShockwave(bodyA);
                        handleShockwave(bodyB);
                    }
                });
            });

            // --- SPAWN LOGIC ---

            function createDuck(x, y, username) {
                // Random Size Multiplier (0.8x to 1.3x)
                const scaleMult = 0.8 + Math.random() * 0.5;
                const baseSize = 50;
                const size = baseSize * scaleMult;

                const body = Bodies.circle(x, y, size/2, {
                    restitution: 0.9, // Very bouncy
                    density: 0.001,   // Light
                    friction: 0.05,
                    render: {
                        sprite: {
                            texture: '../assets/Rubber_Duck.png', // Corrected path
                            xScale: (size / 512), // Assuming roughly 512px image
                            yScale: (size / 512)
                        }
                    }
                });

                // Adjust scale assumption if needed
                const targetSize = size * 2;
                body.render.sprite.xScale = targetSize / 500;
                body.render.sprite.yScale = targetSize / 500;

                body.username = username;
                body.bodyType = 'duck';
                body.visualSize = size;
                return body;
            }

            function createToaster(x, y, username) {
                // Random Size Multiplier (0.8x to 1.5x)
                const scaleMult = 0.8 + Math.random() * 0.7;

                const baseWidth = 70;
                const baseHeight = 50;

                const width = baseWidth * scaleMult;
                const height = baseHeight * scaleMult;

                const body = Bodies.rectangle(x, y, width, height, {
                    restitution: 0.1, // Not bouncy
                    density: 0.05,    // Heavy
                    friction: 0.5,
                    render: {
                        sprite: {
                            texture: '../assets/Toaster.png', // Corrected path
                            xScale: width / 500,
                            yScale: height / 500
                        }
                    }
                });
                body.render.sprite.xScale = (width * 1.5) / 500;
                body.render.sprite.yScale = (height * 1.5) / 500;

                body.username = username;
                body.bodyType = 'toaster';
                body.visualSize = width; // For text scaling
                return body;
            }

            function spawnEvent(username) {
                const x = Math.random() * (window.innerWidth - 100) + 50;
                const y = -100; // Drop from top

                const isDuck = Math.random() < 0.5;
                let body;

                if (isDuck) {
                    body = createDuck(x, y, username);
                } else {
                    body = createToaster(x, y, username);
                }

                Composite.add(engine.world, body);
            }

            // --- START ENGINE ---
            var runner = Runner.create();
            Runner.run(runner, engine);
            Render.run(render);

            // --- STREAMER.BOT CONNECTION ---
            var client = new StreamerbotClient({
                host: '127.0.0.1',
                port: 8080,
                endpoint: '/',
                autoReconnect: true
            });

            client.on('Connect', () => {
                console.log('Connected');
                client.subscribe({
                    "Twitch": ["Follow", "Subscription", "Cheer", "GiftSub", "ReSubscribe"],
                });
            });

            function getSafeData(payload) { return payload.data ? payload.data : payload; }
            function getName(payload) {
                const d = getSafeData(payload);
                if (typeof d.user === 'string') return d.user;
                if (d.user_name) return d.user_name;
                if (d.display_name) return d.display_name;
                if (d.displayName) return d.displayName;
                if (d.userName) return d.userName;
                if (d.name) return d.name;
                return "User";
            }

            // Triggers
            client.on('Twitch.Follow', (payload) => { spawnEvent(getName(payload)); });
            client.on('Twitch.Subscription', (payload) => { spawnEvent(getName(payload)); });
            client.on('Twitch.ReSubscribe', (payload) => { spawnEvent(getName(payload)); });
            client.on('Twitch.GiftSubscription', (payload) => { spawnEvent(getName(payload)); });
            client.on('Twitch.Cheer', (payload) => {
                const d = getSafeData(payload);
                spawnEvent(getName(payload));
            });

            // Expose
            window.spawnEvent = spawnEvent;
            window.openPit = openPit;

        })();
    </script>
</body>
</html>