<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamer.bot Ducks & Toasters</title>
    <!-- Google Fonts: Barlow SemiBold -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@600&display=swap" rel="stylesheet">
    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Streamer.bot Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: transparent;
            font-family: "Barlow", sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Debug & Status Overlay */
        #status-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto;
        }

        .status-msg {
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            max-width: 400px;
        }
        .status-error { color: #ff5555; }
        .status-warn { color: #ffff55; }
        .status-event { color: #55ffff; }
        .status-engine { color: #ff00ff; font-weight: bold; border: 1px solid #ff00ff; }

        /* Controls */
        #controls {
            margin-top: 5px;
            display: flex;
            gap: 5px;
        }
        .debug-btn {
            background: #fff;
            border: 1px solid #ccc;
            padding: 5px 10px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 3px;
        }
        .debug-btn:hover { background: #eee; }

        /* Click to Start Overlay */
        #click-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            cursor: pointer;
            transition: opacity 0.3s;
        }
        #click-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .click-btn {
            background: white;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 24px;
            font-weight: 800;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>

    <div id="status-overlay">
        <div class="status-msg">Initializing...</div>
        <div id="controls">
            <button class="debug-btn" onclick="testSound()">TEST SOUND ðŸ”Š</button>
            <button class="debug-btn" onclick="spawnEvent('TestUser')">SPAWN ðŸ¦†</button>
        </div>
    </div>

    <div id="click-overlay" onclick="enableAudio()">
        <div class="click-btn">CLICK TO ENABLE AUDIO ðŸ”Š</div>
    </div>

    <script>
        (function() {
            // --- LOGGER ---
            function log(msg, type='info') {
                const el = document.getElementById('status-overlay');
                const controls = document.getElementById('controls');

                const line = document.createElement('div');
                line.className = 'status-msg';
                if (type === 'error') line.classList.add('status-error');
                if (type === 'warn') line.classList.add('status-warn');
                if (type === 'event') line.classList.add('status-event');
                if (type === 'engine') line.classList.add('status-engine');
                line.innerText = msg;

                el.insertBefore(line, controls);

                const msgs = el.querySelectorAll('.status-msg');
                if (msgs.length > 10) el.removeChild(msgs[0]);
                console.log(`[Ducks] ${msg}`);
            }

            // --- AUDIO MANAGER (Low Latency) ---
            const AudioManager = {
                ctx: null,
                buffers: {},
                pool: {},
                mode: 'unknown', // 'webaudio' or 'html5'
                assets: {},
                paths: ['assets/', '../assets/'],

                init: function() {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    log("Audio Manager Initialized");
                },

                load: async function(key, filename) {
                    // Try Web Audio Fetch first (Fastest playback)
                    let loaded = false;

                    // 1. Attempt Web Audio Buffer Load
                    for (let path of this.paths) {
                        try {
                            const response = await fetch(path + filename);
                            if (response.ok) {
                                const buffer = await response.arrayBuffer();
                                const audioBuffer = await this.ctx.decodeAudioData(buffer);
                                this.buffers[key] = audioBuffer;
                                this.mode = 'webaudio'; // Prefer this if ANY load succeeds
                                log(`[WebAudio] Loaded ${filename}`, 'info');
                                loaded = true;
                                break;
                            }
                        } catch (e) {
                            // Fetch failed (CORS or 404), try next path or next method
                        }
                    }

                    // 2. Fallback to HTML5 Audio Pool if Web Audio failed
                    if (!loaded) {
                        log(`[WebAudio] Failed for ${filename}, trying HTML5 Pool`, 'warn');
                        // Try loading via Image/Object check or just try Audio element
                        for (let path of this.paths) {
                            if (await this.checkHTML5(path + filename)) {
                                this.createPool(key, path + filename, 5);
                                if (this.mode !== 'webaudio') this.mode = 'html5';
                                log(`[HTML5] Pool Created for ${filename}`, 'info');
                                loaded = true;
                                break;
                            }
                        }
                    }

                    if (!loaded) log(`FAILED to load ${filename}`, 'error');
                },

                checkHTML5: function(url) {
                    return new Promise(resolve => {
                        const a = new Audio();
                        a.src = url;
                        a.oncanplaythrough = () => resolve(true);
                        a.onerror = () => resolve(false);
                    });
                },

                createPool: function(key, url, count) {
                    this.pool[key] = [];
                    for(let i=0; i<count; i++) {
                        const a = new Audio(url);
                        a.preload = 'auto';
                        this.pool[key].push(a);
                    }
                },

                play: function(key) {
                    // Method A: Web Audio
                    if (this.buffers[key]) {
                        if (this.ctx.state === 'suspended') return 'suspended';
                        const source = this.ctx.createBufferSource();
                        source.buffer = this.buffers[key];
                        const gain = this.ctx.createGain();
                        gain.gain.value = 0.5;
                        source.connect(gain);
                        gain.connect(this.ctx.destination);
                        source.start(0);
                        return 'playing';
                    }

                    // Method B: HTML5 Pool
                    if (this.pool[key]) {
                        // Find a free player
                        const p = this.pool[key].find(a => a.paused);
                        if (p) {
                            p.currentTime = 0;
                            p.volume = 0.5;
                            p.play().catch(e => {
                                if (e.name === 'NotAllowedError') {
                                    document.getElementById('click-overlay').classList.remove('hidden');
                                }
                            });
                            return 'playing';
                        } else {
                            // All busy, force one? No, just skip to prevent overlap chaos or clone
                            // log(`Pool exhausted for ${key}`, 'warn');
                        }
                    }
                },

                unlock: function() {
                    if (this.ctx && this.ctx.state === 'suspended') {
                        this.ctx.resume().then(() => log("AudioContext Resumed", 'event'));
                    }
                    // Try to unlock HTML5 pool elements too by playing them briefly
                    for(let k in this.pool) {
                        this.pool[k].forEach(a => {
                            a.play().then(() => { a.pause(); a.currentTime=0; }).catch(() => {});
                        });
                    }
                }
            };

            AudioManager.init();

            // Load Assets
            const loadAll = async () => {
                await AudioManager.load('toaster', 'toaster.wav');
                for(let i=1; i<=6; i++) await AudioManager.load(`duck${i}`, `duck${i}.wav`);

                log(`Audio Engine: ${AudioManager.mode.toUpperCase()}`, 'engine');
            };
            loadAll();

            // Image Loader
            let duckTexturePath = '../assets/Rubber_Duck.png';
            let toasterTexturePath = '../assets/Toaster.png';

            const checkImage = (path) => new Promise(r => {
                const img = new Image();
                img.onload = () => r(path);
                img.onerror = () => r(null);
                img.src = path;
            });

            const resolveImages = async () => {
                let p = await checkImage('assets/Rubber_Duck.png') || await checkImage('../assets/Rubber_Duck.png');
                if (p) duckTexturePath = p;

                p = await checkImage('assets/Toaster.png') || await checkImage('../assets/Toaster.png');
                if (p) toasterTexturePath = p;

                log("Images Resolved", 'info');
            };
            resolveImages();


            // --- GLOBAL CONTROLS ---
            window.enableAudio = function() {
                document.getElementById('click-overlay').classList.add('hidden');
                AudioManager.unlock();
            };

            window.testSound = function() {
                const type = Math.random() < 0.5 ? 'toaster' : 'duck';
                log(`Test: ${type}`, 'event');
                playSound(type);
            };

            function playSound(type) {
                if (type === 'toaster') {
                    AudioManager.play('toaster');
                } else if (type === 'duck') {
                    const idx = Math.ceil(Math.random() * 6);
                    AudioManager.play(`duck${idx}`);
                }
            }

            // --- PHYSICS ENGINE ---
            const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
                  Bodies = Matter.Bodies, Body = Matter.Body, Composite = Matter.Composite,
                  Events = Matter.Events, Vector = Matter.Vector;

            const engine = Engine.create({ positionIterations: 20, velocityIterations: 20, enableSleeping: true });
            const render = Render.create({
                element: document.body,
                engine: engine,
                options: { width: window.innerWidth, height: window.innerHeight, background: 'transparent', wireframes: false }
            });

            // Walls
            const wallOpts = { isStatic: true, render: { visible: false } };
            Composite.add(engine.world, [
                Bodies.rectangle(window.innerWidth/2, window.innerHeight + 100, window.innerWidth, 200, wallOpts), // Floor
                Bodies.rectangle(-100, window.innerHeight/2, 200, window.innerHeight * 5, wallOpts), // Left
                Bodies.rectangle(window.innerWidth + 100, window.innerHeight/2, 200, window.innerHeight * 5, wallOpts), // Right
                Bodies.rectangle(window.innerWidth/2, -500, window.innerWidth, 200, wallOpts) // Ceiling
            ]);

            // --- COLLISION LOGIC ---
            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach((pair) => {
                    const bodyA = pair.bodyA;
                    const bodyB = pair.bodyB;

                    // Allow collisions with walls (static) to trigger sound
                    // We simply remove the early return for isStatic

                    const impact = bodyA.speed + bodyB.speed;
                    if (impact > 2.0) {
                        if (bodyA.bodyType === 'duck' || bodyB.bodyType === 'duck') playSound('duck');
                        if (bodyA.bodyType === 'toaster' || bodyB.bodyType === 'toaster') playSound('toaster');

                        // Shockwave
                        if ((bodyA.bodyType === 'toaster' || bodyB.bodyType === 'toaster') && impact > 5.0) {
                            const origin = bodyA.bodyType === 'toaster' ? bodyA : bodyB;
                            Composite.allBodies(engine.world).forEach(b => {
                                if (b === origin || b.isStatic) return;
                                const dist = Vector.magnitude(Vector.sub(b.position, origin.position));
                                if (dist < 250) {
                                    const dir = Vector.normalise(Vector.sub(b.position, origin.position));
                                    Body.applyForce(b, b.position, Vector.mult(dir, 0.1 * (impact/10)));
                                }
                            });
                        }
                    }
                });
            });

            // --- SPAWN LOGIC ---
            function spawnEvent(username) {
                const x = Math.random() * (window.innerWidth - 100) + 50;
                const isDuck = Math.random() < 0.5;

                let body;
                if (isDuck) {
                    const size = 50 * (0.8 + Math.random() * 0.5);
                    body = Bodies.circle(x, -100, size/2, {
                        restitution: 0.9, density: 0.001, friction: 0.05,
                        render: { sprite: { texture: duckTexturePath, xScale: size/512, yScale: size/512 } }
                    });
                    body.bodyType = 'duck';
                    body.visualSize = size;
                } else {
                    const w = 70 * (0.8 + Math.random() * 0.7);
                    const h = 50 * (0.8 + Math.random() * 0.7);
                    body = Bodies.rectangle(x, -100, w, h, {
                        restitution: 0.1, density: 0.05, friction: 0.5,
                        render: { sprite: { texture: toasterTexturePath, xScale: w/500, yScale: h/500 } }
                    });
                    body.bodyType = 'toaster';
                    body.visualSize = w;
                }
                body.username = username;
                Composite.add(engine.world, body);
            }

            // --- RENDER TEXT ---
            Events.on(render, 'afterRender', () => {
                const ctx = render.context;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.lineWidth = 3;
                Composite.allBodies(engine.world).forEach(b => {
                    if (b.username) {
                        const size = Math.max(12, (b.visualSize || 35) * 0.5);
                        ctx.font = `800 ${size}px "Barlow", Arial, sans-serif`;
                        ctx.fillStyle = 'white'; ctx.strokeStyle = 'black';
                        ctx.save();
                        ctx.translate(b.position.x, b.position.y);
                        ctx.rotate(b.angle);
                        ctx.strokeText(b.username, 0, 0);
                        ctx.fillText(b.username, 0, 0);
                        ctx.restore();
                    }
                });
            });

            // --- START ---
            Runner.run(Runner.create(), engine);
            Render.run(render);

            // --- STREAMER.BOT ---
            const client = new StreamerbotClient({ host: '127.0.0.1', port: 8080, endpoint: '/', autoReconnect: true });
            client.on('Connect', () => {
                log('Connected to SB');
                client.subscribe({ "Twitch": ["Follow", "Subscription", "Cheer", "GiftSub", "ReSubscribe"] });
            });
            const getName = (p) => (p.data || p).user_name || (p.data || p).user || "User";
            client.on('Twitch.Follow', (p) => spawnEvent(getName(p)));
            client.on('Twitch.Subscription', (p) => spawnEvent(getName(p)));
            client.on('Twitch.Cheer', (p) => spawnEvent(getName(p)));

            window.spawnEvent = spawnEvent;
        })();
    </script>
</body>
</html>