<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamer.bot Ducks & Toasters</title>
    <!-- Google Fonts: Barlow SemiBold -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@600&display=swap" rel="stylesheet">
    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Streamer.bot Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: transparent;
            font-family: "Barlow", sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Debug & Status Overlay */
        #status-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto; /* Allow clicking test buttons */
        }

        .status-msg {
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            max-width: 400px;
        }
        .status-error { color: #ff5555; }
        .status-warn { color: #ffff55; }
        .status-event { color: #55ffff; }

        /* Controls */
        #controls {
            margin-top: 5px;
            display: flex;
            gap: 5px;
        }
        .debug-btn {
            background: #fff;
            border: 1px solid #ccc;
            padding: 5px 10px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 3px;
        }
        .debug-btn:hover { background: #eee; }

        /* Click to Start Overlay */
        #click-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            cursor: pointer;
            transition: opacity 0.3s;
        }
        #click-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .click-btn {
            background: white;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 24px;
            font-weight: 800;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>

    <div id="status-overlay">
        <div class="status-msg">Initializing...</div>
        <div id="controls">
            <button class="debug-btn" onclick="testSound()">TEST SOUND ðŸ”Š</button>
            <button class="debug-btn" onclick="spawnEvent('TestUser')">SPAWN ðŸ¦†</button>
        </div>
    </div>

    <div id="click-overlay" onclick="enableAudio()">
        <div class="click-btn">CLICK TO ENABLE AUDIO ðŸ”Š</div>
    </div>

    <script>
        (function() {
            // --- LOGGER ---
            function log(msg, type='info') {
                const el = document.getElementById('status-overlay');

                // Add new message before controls
                const controls = document.getElementById('controls');

                const line = document.createElement('div');
                line.className = 'status-msg';
                if (type === 'error') line.classList.add('status-error');
                if (type === 'warn') line.classList.add('status-warn');
                if (type === 'event') line.classList.add('status-event');
                line.innerText = msg;

                el.insertBefore(line, controls);

                // Keep only last 10 lines (excluding controls)
                const msgs = el.querySelectorAll('.status-msg');
                if (msgs.length > 10) {
                    el.removeChild(msgs[0]);
                }
                console.log(`[Ducks] ${msg}`);
            }

            // --- HTML5 AUDIO LOADER ---
            // Reverted to HTML5 Audio to avoid CORS issues with fetch() on file://
            const ASSETS = {};
            const ASSET_PATHS = [
                'assets/',
                '../assets/'
            ];

            function loadAudio(key, filename) {
                return new Promise((resolve, reject) => {
                    let attempt = 0;

                    function tryLoad() {
                        if (attempt >= ASSET_PATHS.length) {
                            log(`Failed to load ${filename}`, 'error');
                            ASSETS[key] = null;
                            resolve(null);
                            return;
                        }

                        const path = ASSET_PATHS[attempt] + filename;
                        const audio = new Audio();
                        audio.src = path;

                        // We set preload to auto
                        audio.preload = "auto";
                        audio.volume = 0.5;

                        // Check if it loads
                        audio.oncanplaythrough = () => {
                            // Prevent multiple fires
                            audio.oncanplaythrough = null;
                            audio.onerror = null;
                            log(`Loaded: ${filename}`, 'info');
                            ASSETS[key] = audio;
                            resolve(audio);
                        };

                        audio.onerror = (e) => {
                            // Try next path
                            attempt++;
                            tryLoad();
                        };

                        // Force load
                        audio.load();
                    }
                    tryLoad();
                });
            }

            function loadImagePath(filename) {
                return new Promise((resolve) => {
                    let attempt = 0;
                    function tryLoad() {
                        if (attempt >= ASSET_PATHS.length) {
                            log(`Failed to load image ${filename}`, 'error');
                            resolve(null);
                            return;
                        }
                        const path = ASSET_PATHS[attempt] + filename;
                        const img = new Image();
                        img.onload = () => resolve(path);
                        img.onerror = () => { attempt++; tryLoad(); };
                        img.src = path;
                    }
                    tryLoad();
                });
            }

            // Preload All
            const loaders = [];
            loaders.push(loadAudio('toaster', 'toaster.wav'));
            for(let i=1; i<=6; i++) loaders.push(loadAudio(`duck${i}`, `duck${i}.wav`));

            let duckTexturePath = '../assets/Rubber_Duck.png';
            let toasterTexturePath = '../assets/Toaster.png';

            loaders.push(loadImagePath('Rubber_Duck.png').then(p => { if(p) duckTexturePath = p; }));
            loaders.push(loadImagePath('Toaster.png').then(p => { if(p) toasterTexturePath = p; }));

            Promise.all(loaders).then(() => {
                log("Assets Loading Complete");
            });

            // --- AUDIO CONTROL ---
            window.enableAudio = function() {
                const overlay = document.getElementById('click-overlay');
                overlay.classList.add('hidden');

                // Try to play silent
                if (ASSETS['toaster']) {
                    ASSETS['toaster'].play()
                        .then(() => {
                            ASSETS['toaster'].pause();
                            ASSETS['toaster'].currentTime = 0;
                            log("Audio Unlocked");
                        })
                        .catch(e => log(`Unlock Failed: ${e.message}`, 'warn'));
                }
            };

            window.testSound = function() {
                log("Testing Sound...", 'event');
                playSound('duck');
            };

            function playSound(type) {
                let original = null;
                if (type === 'toaster') {
                    original = ASSETS['toaster'];
                } else if (type === 'duck') {
                    const available = [];
                    for(let i=1; i<=6; i++) if (ASSETS[`duck${i}`]) available.push(ASSETS[`duck${i}`]);
                    if (available.length > 0) {
                        original = available[Math.floor(Math.random() * available.length)];
                    }
                }

                if (original) {
                    // Clone to allow overlapping sounds
                    // Note: cloneNode() on Audio elements works efficiently
                    const clone = original.cloneNode();
                    clone.volume = 0.5;
                    const p = clone.play();

                    if (p !== undefined) {
                        p.then(() => {
                            // log(`Played: ${type}`, 'info');
                        }).catch(e => {
                            log(`Play Blocked: ${e.message}`, 'error');
                            if (e.name === 'NotAllowedError') {
                                document.getElementById('click-overlay').classList.remove('hidden');
                            }
                        });
                    }
                } else {
                    // log(`No Asset for ${type}`, 'warn');
                }
            }

            // --- PHYSICS ENGINE SETUP ---
            const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
                  Bodies = Matter.Bodies, Body = Matter.Body, Composite = Matter.Composite,
                  Events = Matter.Events, Vector = Matter.Vector, Sleeping = Matter.Sleeping;

            const engine = Engine.create({ positionIterations: 20, velocityIterations: 20, enableSleeping: true });

            const render = Render.create({
                element: document.body,
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    pixelRatio: 1,
                    background: 'transparent',
                    wireframes: false,
                    showAngleIndicator: false
                }
            });

            // --- ENVIRONMENT ---
            const wallOpts = { isStatic: true, render: { visible: false } };
            const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight + 100, window.innerWidth, 200, wallOpts);
            const leftWall = Bodies.rectangle(-100, window.innerHeight/2, 200, window.innerHeight * 5, wallOpts);
            const rightWall = Bodies.rectangle(window.innerWidth + 100, window.innerHeight/2, 200, window.innerHeight * 5, wallOpts);
            const ceiling = Bodies.rectangle(window.innerWidth/2, -500, window.innerWidth, 200, wallOpts);

            Composite.add(engine.world, [ground, leftWall, rightWall, ceiling]);

            // --- RENDER TEXT ---
            Events.on(render, 'afterRender', function() {
                const context = render.context;
                const bodies = Composite.allBodies(engine.world);
                context.textAlign = 'center';
                context.textBaseline = 'middle';

                for (let i = 0; i < bodies.length; i += 1) {
                    const body = bodies[i];
                    if (body.username) {
                        const dim = body.visualSize || 35;
                        const mainSize = Math.max(12, dim * 0.5);

                        context.font = `800 ${mainSize}px "Barlow", Arial, sans-serif`;
                        context.lineWidth = 3;
                        context.strokeStyle = `black`;
                        context.fillStyle = `white`;

                        context.save();
                        context.translate(body.position.x, body.position.y);
                        context.rotate(body.angle);
                        context.strokeText(body.username, 0, 0);
                        context.fillText(body.username, 0, 0);
                        context.restore();
                    }
                }
            });

            // --- COLLISION ---
            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach((pair) => {
                    const bodyA = pair.bodyA;
                    const bodyB = pair.bodyB;

                    if (bodyA.isStatic || bodyB.isStatic) return;

                    const speedA = bodyA.speed;
                    const speedB = bodyB.speed;
                    const impact = speedA + speedB;

                    if (impact > 2.0) {
                        // Debug log for heavy impacts to verify physics
                        if (impact > 10.0) {
                           // log(`Impact: ${impact.toFixed(1)}`, 'info');
                        }

                        // Sound logic
                        if (bodyA.bodyType === 'duck' || bodyB.bodyType === 'duck') {
                             if (Math.random() < 0.3) playSound('duck');
                        }
                        if (bodyA.bodyType === 'toaster' || bodyB.bodyType === 'toaster') {
                             if (Math.random() < 0.3) playSound('toaster');
                        }

                        // Shockwave
                        const handleShockwave = (originBody) => {
                            if (originBody.bodyType !== 'toaster') return;
                            if (impact < 5.0) return;

                            const center = originBody.position;
                            const range = 250;
                            const forceMag = 0.1 * (impact / 10);

                            Composite.allBodies(engine.world).forEach(b => {
                                if (b === originBody || b.isStatic) return;
                                const dist = Vector.magnitude(Vector.sub(b.position, center));
                                if (dist < range) {
                                    const dir = Vector.normalise(Vector.sub(b.position, center));
                                    Body.applyForce(b, b.position, Vector.mult(dir, forceMag));
                                }
                            });
                        };

                        handleShockwave(bodyA);
                        handleShockwave(bodyB);
                    }
                });
            });

            // --- SPAWN LOGIC ---
            function createDuck(x, y, username) {
                const scaleMult = 0.8 + Math.random() * 0.5;
                const baseSize = 50;
                const size = baseSize * scaleMult;

                const body = Bodies.circle(x, y, size/2, {
                    restitution: 0.9,
                    density: 0.001,
                    friction: 0.05,
                    render: {
                        sprite: {
                            texture: duckTexturePath,
                            xScale: (size / 512),
                            yScale: (size / 512)
                        }
                    }
                });

                body.username = username;
                body.bodyType = 'duck';
                body.visualSize = size;
                return body;
            }

            function createToaster(x, y, username) {
                const scaleMult = 0.8 + Math.random() * 0.7;
                const width = 70 * scaleMult;
                const height = 50 * scaleMult;

                const body = Bodies.rectangle(x, y, width, height, {
                    restitution: 0.1,
                    density: 0.05,
                    friction: 0.5,
                    render: {
                        sprite: {
                            texture: toasterTexturePath,
                            xScale: width / 500,
                            yScale: height / 500
                        }
                    }
                });

                body.render.sprite.xScale = (width * 1.5) / 500;
                body.render.sprite.yScale = (height * 1.5) / 500;

                body.username = username;
                body.bodyType = 'toaster';
                body.visualSize = width;
                return body;
            }

            function spawnEvent(username) {
                const x = Math.random() * (window.innerWidth - 100) + 50;
                const y = -100;
                const isDuck = Math.random() < 0.5;
                const body = isDuck ? createDuck(x, y, username) : createToaster(x, y, username);
                Composite.add(engine.world, body);
                // log(`Spawned: ${isDuck ? 'Duck' : 'Toaster'}`, 'event');
            }

            // --- RUNNER ---
            var runner = Runner.create();
            Runner.run(runner, engine);
            Render.run(render);

            // --- SB CONNECTION ---
            var client = new StreamerbotClient({
                host: '127.0.0.1',
                port: 8080,
                endpoint: '/',
                autoReconnect: true
            });

            client.on('Connect', () => {
                log('SB Connected');
                client.subscribe({ "Twitch": ["Follow", "Subscription", "Cheer", "GiftSub", "ReSubscribe"] });
            });

            function getName(payload) {
                const d = payload.data || payload;
                return d.user_name || d.user || d.displayName || "User";
            }

            client.on('Twitch.Follow', (p) => spawnEvent(getName(p)));
            client.on('Twitch.Subscription', (p) => spawnEvent(getName(p)));
            client.on('Twitch.ReSubscribe', (p) => spawnEvent(getName(p)));
            client.on('Twitch.GiftSubscription', (p) => spawnEvent(getName(p)));
            client.on('Twitch.Cheer', (p) => spawnEvent(getName(p)));

            window.spawnEvent = spawnEvent;
            window.openPit = () => {}; // Placeholder

        })();
    </script>
</body>
</html>