<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamer.bot Ball Pit</title>
    <!-- Global CSS -->
    <link rel="stylesheet" href="../shared/css/common.css">
    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Streamer.bot Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
</head>
<body>

    <!-- Audio element for the cheer sound -->
    <audio id="cheer-audio" src="assets/cheer.wav" preload="auto"></audio>

    <script>
        (function() { // Wrap in IIFE to prevent redeclaration errors
            // --- 1. PHYSICS ENGINE SETUP ---
            const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
                  Bodies = Matter.Bodies, Body = Matter.Body, Composite = Matter.Composite,
                  Events = Matter.Events, Vector = Matter.Vector, Sleeping = Matter.Sleeping;

            const engine = Engine.create({ positionIterations: 20, velocityIterations: 20, enableSleeping: true });

            // Render must be defined outside the loops
            const render = Render.create({
                element: document.body,
                engine: engine,
                options: { width: window.innerWidth, height: window.innerHeight, pixelRatio: 1, background: 'transparent', wireframes: false }
            });

            // --- ENVIRONMENT SETUP ---
            const wallOpts = { isStatic: true, render: { visible: false } };
            const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight + 100, window.innerWidth, 200, wallOpts);
            const leftWall = Bodies.rectangle(-100, window.innerHeight/2, 200, window.innerHeight * 5, wallOpts);
            const rightWall = Bodies.rectangle(window.innerWidth + 100, window.innerHeight/2, 200, window.innerHeight * 5, wallOpts);
            // CEILING at -100 to keep balls inside
            const ceiling = Bodies.rectangle(window.innerWidth/2, -100, window.innerWidth, 200, wallOpts);

            Composite.add(engine.world, [ground, leftWall, rightWall, ceiling]);

            // --- FLUSH MECHANIC ---
            var isPitOpen = false;
            function openPit() {
                if (isPitOpen) return;
                isPitOpen = true;
                Composite.remove(engine.world, ground);

                Composite.allBodies(engine.world).forEach(body => {
                    if (!body.isStatic) {
                        Sleeping.set(body, false);
                        Body.setVelocity(body, { x: 0, y: 0 });
                        Body.setVelocity(body, { x: (Math.random() - 0.5) * 5, y: 15 });
                    }
                });

                setTimeout(() => {
                    Body.setPosition(ground, { x: window.innerWidth / 2, y: window.innerHeight + 100 });
                    Body.setVelocity(ground, { x: 0, y: 0 });
                    Composite.add(engine.world, ground);
                    isPitOpen = false;
                }, 5000);
            }

            // Garbage Collector
            setInterval(() => {
                const bodies = Composite.allBodies(engine.world);
                bodies.forEach(body => {
                    if (body.position.y > window.innerHeight + 2000) Composite.remove(engine.world, body);
                });
            }, 2000);

            // --- PREVENT DIMMING & EXPLOSION HOOKS ---
            Events.on(engine, 'beforeUpdate', function() {
                Composite.allBodies(engine.world).forEach(body => { if (body.isExplosive && body.isSleeping) detonateBall(body); });
            });

            // --- CORE FADING LOGIC ---
            Events.on(engine, 'afterUpdate', function() {
                Composite.allBodies(engine.world).forEach(body => {
                    if (body.isFading && body.isSleeping) {
                        body.isFading = false;
                        body.isSettledFading = true;
                        body.flashTimer = performance.now() + (Math.random() * 8000);
                    }
                });
            });

            Events.on(render, 'beforeRender', function() {
                Composite.allBodies(engine.world).forEach(body => { if (body.isSleeping) { body.fakeWake = true; body.isSleeping = false; }});
            });

            // --- CUSTOM RENDERER ---
            Events.on(render, 'afterRender', function() {
                Composite.allBodies(engine.world).forEach(body => { if (body.fakeWake) { body.isSleeping = true; body.fakeWake = false; }});

                const context = render.context;
                const bodies = Composite.allBodies(engine.world);
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.strokeStyle = 'black';

                function getColorRgb(color) {
                    if (color === 'gold') return [255, 215, 0];
                    if (color === 'red' || color === 'rgba(51, 51, 51, 1)') return [255, 0, 0];
                    if (color.startsWith('rgba')) {
                        const matches = color.match(/\d+/g);
                        if (matches && matches.length >= 3) return matches.slice(0, 3).map(Number);
                    }
                    return [255, 255, 255];
                }

                for (let i = 0; i < bodies.length; i += 1) {
                    const body = bodies[i];
                    if (body.username) {
                        const radius = body.circleRadius || 20;
                        let fillStyle = body.render.fillStyle;

                        if (body.isFading || body.isSettledFading) {
                            const time = performance.now();
                            let opacity;
                            let cycleTime;

                            if (body.isSettledFading) {
                                cycleTime = 8000;
                                opacity = 0.5 + 0.5 * Math.sin((time - (body.flashTimer || 0)) * (2 * Math.PI / cycleTime));
                            } else {
                                cycleTime = 6000;
                                opacity = 0.9 + 0.1 * Math.sin((time - (body.flashTimer || 0)) * (2 * Math.PI / cycleTime));
                            }

                            const baseRgb = getColorRgb(fillStyle);
                            body.render.fillStyle = `rgba(${baseRgb[0]}, ${baseRgb[1]}, ${baseRgb[2]}, ${opacity})`;
                        }

                        if (body.topLabel || body.bottomLabel) {
                            const mainSize = Math.max(12, radius * 0.4);
                            const subSize = Math.max(10, radius * 0.25);

                            if (body.topLabel) {
                                context.font = `600 ${subSize}px "Barlow", Arial, sans-serif`;
                                context.lineWidth = Math.max(2, subSize * 0.1);
                                context.strokeStyle = `rgba(0, 0, 0, 1.0)`;
                                context.fillStyle = `rgba(255, 255, 255, 1.0)`;
                                context.strokeText(body.topLabel, body.position.x, body.position.y - (radius * 0.4));
                                context.fillText(body.topLabel, body.position.x, body.position.y - (radius * 0.4));
                            }

                            context.font = `600 ${mainSize}px "Barlow", Arial, sans-serif`;
                            context.lineWidth = Math.max(2.5, mainSize * 0.1);
                            context.strokeStyle = `rgba(0, 0, 0, 1.0)`;
                            context.fillStyle = `rgba(255, 255, 255, 1.0)`;
                            context.strokeText(body.username, body.position.x, body.position.y);
                            context.fillText(body.username, body.position.x, body.position.y);

                            if (body.bottomLabel) {
                                context.font = `600 ${subSize}px "Barlow", Arial, sans-serif`;
                                context.lineWidth = Math.max(2, subSize * 0.1);
                                context.strokeStyle = `rgba(0, 0, 0, 1.0)`;
                                context.fillStyle = `rgba(255, 255, 255, 1.0)`;
                                context.strokeText(body.bottomLabel, body.position.x, body.position.y + (radius * 0.4));
                                context.fillText(body.bottomLabel, body.position.x, body.position.y + (radius * 0.4));
                            }

                        } else {
                            const MAX_FONT_SIZE = 80;
                            const MIN_FONT_SIZE = 12;
                            const availableWidth = radius * 1.8;

                            let fontSize = radius * 0.7;

                            context.font = `600 ${fontSize}px "Barlow", Arial, sans-serif`;
                            const textWidth = context.measureText(body.username).width;

                            if (textWidth > availableWidth) {
                                fontSize = fontSize * (availableWidth / textWidth);
                            }

                            fontSize = Math.max(fontSize, MIN_FONT_SIZE);
                            fontSize = Math.min(fontSize, MAX_FONT_SIZE);

                            context.font = `600 ${fontSize}px "Barlow", Arial, sans-serif`;
                            context.lineWidth = Math.max(2.5, fontSize * 0.08);

                            context.strokeStyle = `rgba(0, 0, 0, 1.0)`;
                            context.strokeText(body.username, body.position.x, body.position.y);
                            context.fillStyle = `rgba(255, 255, 255, 1.0)`;
                            context.fillText(body.username, body.position.x, body.position.y);
                        }
                    }
                }
            });

            // --- EXPLOSION LOGIC ---
            function detonateBall(bombBody) {
                const explosionCenter = bombBody.position;
                const explosionRadius = bombBody.circleRadius * 6;
                const explosionForce = 0.05 + (bombBody.circleRadius / 200);

                const storedLabel = bombBody.bottomLabel;

                Composite.remove(engine.world, bombBody);
                playBounce(20, bombBody.circleRadius, true);

                const currentTier = bombBody.explosionTier || 0;
                const isMegaBombLaunch = currentTier === 1;
                const isSecondaryBomb = currentTier === 2;

                let debrisRadius;
                let debrisIsExplosive;
                let nextTier = 0;
                let isFading = false;
                let debrisCount = Math.max(5, Math.floor(bombBody.circleRadius / 10));

                if (isMegaBombLaunch) {
                    debrisCount = 2;
                    debrisRadius = bombBody.circleRadius;
                    debrisIsExplosive = true;
                    nextTier = 2;
                } else if (isSecondaryBomb) {
                    debrisCount = Math.floor(Math.random() * 2) + 5;
                    debrisRadius = Math.floor(bombBody.circleRadius * 0.9);
                    debrisIsExplosive = false;
                    nextTier = 0;
                    isFading = true;
                } else {
                    if (bombBody.customDebrisCount) {
                        debrisCount = bombBody.customDebrisCount;
                    } else {
                        debrisCount = Math.max(5, Math.floor(bombBody.circleRadius / 10));
                    }

                    if (bombBody.customDebrisRadius) {
                        debrisRadius = bombBody.customDebrisRadius;
                    } else {
                        debrisRadius = Math.min(35, Math.max(12, Math.floor(bombBody.circleRadius / 4)));
                    }

                    debrisIsExplosive = false;
                    nextTier = 0;
                }

                debrisRadius = Math.max(12, debrisRadius);

                for (let i = 0; i < debrisCount; i++) {
                    const angle = (Math.PI * 2 / debrisCount) * i;
                    let variedRadius = debrisRadius * (0.8 + Math.random() * 0.4);

                    const debris = createBallBody(
                        explosionCenter.x + Math.cos(angle)*10,
                        explosionCenter.y + Math.sin(angle)*10,
                        variedRadius,
                        bombBody.username,
                        debrisIsExplosive
                    );

                    if (i === 0 && storedLabel) {
                        debris.bottomLabel = storedLabel;
                    }

                    if (nextTier > 0) debris.explosionTier = nextTier;

                    if (isFading) {
                        debris.isFading = true;
                        debris.flashTimer = performance.now() + (Math.random() * 1000);
                        debris.render.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    } else if (nextTier === 2) {
                        debris.render.fillStyle = 'gold';
                    }

                    Body.applyForce(debris, debris.position, { x: Math.cos(angle) * 0.005, y: Math.sin(angle) * 0.005 });
                    Composite.add(engine.world, debris);
                }

                Composite.allBodies(engine.world).forEach(body => {
                    if (body.isStatic) return;
                    const forceVector = Vector.sub(body.position, explosionCenter);
                    const distance = Vector.magnitude(forceVector);
                    if (distance < explosionRadius) {
                        let normal = distance > 0.1 ? Vector.normalise(forceVector) : { x: Math.random() - 0.5, y: -1 };
                        const forceMagnitude = explosionForce * (1 - distance / explosionRadius);
                        Sleeping.set(body, false);
                        Body.applyForce(body, body.position, { x: normal.x * forceMagnitude, y: normal.y * forceMagnitude });
                    }
                });
            }

            // --- AUDIO ---
            var AudioContext = window.AudioContext || window.webkitAudioContext;
            var audioCtx = new AudioContext();
            window.addEventListener('click', () => { if (audioCtx.state === 'suspended') audioCtx.resume(); }, { once: true });

            function playCheerSound() {
                playDing();
            }

            function playDing() {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 1.5);
                const sparkle = audioCtx.createOscillator(); const sGain = audioCtx.createGain();
                sparkle.type = 'triangle'; sparkle.frequency.setValueAtTime(2000, now);
                sGain.gain.setValueAtTime(0.05, now); sGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                sparkle.connect(sGain); sGain.connect(audioCtx.destination); sparkle.start(now); sparkle.stop(now + 0.3);
            }

            function playBounce(intensity, radius, force = false) {
                if (audioCtx.state === 'suspended') return;
                const volume = Math.min(intensity * 0.1, 0.4);
                if (volume < 0.02) return;
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                const safeRadius = radius || 30;
                const baseFreq = 25000 / safeRadius;
                const frequency = baseFreq + (intensity * 10);
                osc.frequency.setValueAtTime(frequency, now);
                osc.frequency.exponentialRampToValueAtTime(frequency * 0.5, now + 0.08);
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(volume, now + 0.002);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.1);
            }

            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach((pair) => {
                    const speedA = pair.bodyA.speed; const speedB = pair.bodyB.speed; const impact = speedA + speedB;
                    if (impact > 3.0) {
                        const maxRadius = Math.max(pair.bodyA.circleRadius || 0, pair.bodyB.circleRadius || 0);
                        if (maxRadius > 0) playBounce(impact, maxRadius);
                    }
                });
            });

            // --- GAMEPLAY LOGIC ---
            var colors = ['rgb(255, 0, 0)', 'rgb(255, 234, 0)', 'rgb(5, 255, 116)', 'rgb(95, 255, 255)'];

            function createBallBody(x, y, radius, username, isExplosive = false) {
                let color = colors[Math.floor(Math.random() * colors.length)];
                if (isExplosive) color = '#333';
                const ball = Bodies.circle(x, y, radius, { restitution: 0.9, friction: 0.001, render: { fillStyle: color } });
                ball.username = username.toUpperCase(); ball.isExplosive = isExplosive; return ball;
            }

            function determineDropType() {
                const rand = Math.random();
                if (rand < 0.015) return 'huge';    // 1.5% Chance
                if (rand < 0.065) return 'cluster';  // 5% Chance
                if (rand < 0.15) return 'exploding'; // 8.5% Chance
                return 'normal';                     // 85% Chance
            }

            // UPDATED SPAWN EVENT
            function spawnEvent(type, username, customRadius = 30, explosionTier = 0, isFading = false, topLabel = "", bottomLabel = "", customDebrisCount = 0, customDebrisRadius = 0) {
                const x = Math.random() * window.innerWidth;
                const y = 150; // SPAWN INSIDE THE BOX (Safe from ceiling)

                let ball;

                if (type === 'huge') {
                    const radius = (customRadius > 60 ? customRadius : 100) + Math.random() * 30;
                    ball = createBallBody(x, y, radius, username);
                } else if (type === 'cluster') {
                    for(let i=0; i<10; i++) setTimeout(() => {
                        const rainX = Math.random() * window.innerWidth;
                        let r = 15 + Math.random() * 30;
                        let b = createBallBody(rainX, y + (Math.random() * 300), r, username);
                        Composite.add(engine.world, b);
                    }, i * 50);
                    return; // Cluster returns early
                } else if (type === 'exploding') {
                    const radius = customRadius + Math.random() * 10;
                    ball = createBallBody(x, y, radius, username, true);
                    ball.explosionTier = explosionTier;
                    if (customDebrisCount > 0) ball.customDebrisCount = customDebrisCount;
                    if (customDebrisRadius > 0) ball.customDebrisRadius = customDebrisRadius;
                } else {
                    const radius = customRadius;
                    ball = createBallBody(x, y, radius, username);
                    if (isFading) {
                        ball.isSettledFading = true;
                        ball.flashTimer = performance.now() + (Math.random() * 8000);
                    }
                }

                if (ball) {
                    if (topLabel) ball.topLabel = topLabel;
                    if (bottomLabel) ball.bottomLabel = bottomLabel;
                    Composite.add(engine.world, ball);
                }
                playDing();
            }

            // --- START MATTER.JS LOOPS ---
            var runner = Runner.create();
            Runner.run(runner, engine);
            Render.run(render);
            // --- END START MATTER.JS LOOPS ---


            // --- STREAMER.BOT CONNECTION ---
            var client;
            try {
                if (typeof StreamerbotClient !== 'undefined') {
                    client = new StreamerbotClient({
                        host: '127.0.0.1',
                        port: 8080,
                        endpoint: '/',
                        autoReconnect: true
                    });

                    client.on('Connect', () => {
                        console.log('Connected');
                        client.subscribe({
                            "Twitch": [
                                "Follow",
                                "ChatMessage",
                                "Cheer",
                                "Announcement",
                                "Subscribe",
                                "ReSubscribe",
                                "GiftSubscription",
                                "Subscription",
                                "GiftSub",
                                "Sub"
                            ],
                            "General": ["Custom"]
                        });
                    });
                }
            } catch (e) { console.error("SB Client Init Error", e); }

            function getSafeData(payload) { return payload.data ? payload.data : payload; }

            function getName(payload) {
                const d = getSafeData(payload);
                if (typeof d.user === 'string') return d.user;
                if (d.user_name) return d.user_name;
                if (d.display_name) return d.display_name;
                if (d.displayName) return d.displayName;
                if (d.userName) return d.userName;

                if (d.user && typeof d.user === 'object') {
                    if (d.user.name) return d.user.name;
                    if (d.user.display_name) return d.user.display_name;
                    if (d.user.displayName) return d.user.displayName;
                    if (d.user.login) return d.user.login;
                }

                if (d.sender && typeof d.sender === 'object') {
                     if (d.sender.name) return d.sender.name;
                     if (d.sender.display_name) return d.sender.display_name;
                }

                if (d.name) return d.name;
                return "User";
            }

            function getTierFromPayload(payload) {
                const d = getSafeData(payload);
                return d.tier || d.sub_tier || d.plan || d.subPlan || '1000';
            }

            // 1. FOLLOWS
            if (client) client.on('Twitch.Follow', (payload) => {
                const username = getName(payload);
                const dropType = determineDropType();
                const radius = 15 + Math.random() * 70;
                spawnEvent(dropType, username, radius);
            });

            // HANDLER FOR SUBSCRIPTIONS
            const handleSub = (payload) => {
                const d = getSafeData(payload);
                const username = getName(payload);
                const tierCodeRaw = getTierFromPayload(payload);
                const tierCode = String(tierCodeRaw).toLowerCase().replace(/\s/g, '');

                const isPrime = d.is_prime === true || d.isPrime === true;

                let baseRadius;
                let tierText = "Tier 1";

                if (tierCode === '3000' || tierCode === 'tier3') {
                     baseRadius = 100; // Fixed Huge
                     tierText = "Tier 3";
                } else if (tierCode === '2000' || tierCode === 'tier2') {
                     baseRadius = 75; // Fixed Large
                     tierText = "Tier 2";
                } else if (tierCode.includes('prime') || isPrime) {
                     baseRadius = 50; // Fixed Medium
                     tierText = "Prime";
                } else {
                     baseRadius = 50; // Fixed Medium for Tier 1
                     tierText = "Tier 1";
                }

                spawnEvent('normal', username, baseRadius, 0, false, "SUB", tierText);
            };

            if (client) {
                client.on('Twitch.Subscribe', handleSub);
                client.on('Twitch.ReSubscribe', handleSub);
                client.on('Twitch.GiftSubscription', handleSub);
                client.on('Twitch.Subscription', handleSub);
                client.on('Twitch.GiftSub', handleSub);
                client.on('Twitch.Sub', handleSub);
            }

            // 2. CHEERS
            if (client) client.on('Twitch.Cheer', (payload) => {
                const d = getSafeData(payload);
                const username = getName(payload);
                const bits = d.bits || 1;
                const bitLabel = bits + " bits";

                if (bits >= 1000) playDing();

                let baseRadius = 15 + Math.sqrt(bits) * 2.5;
                const MAX_RADIUS = 200;
                baseRadius = Math.min(baseRadius, MAX_RADIUS);

                let dropType = 'normal';
                let explosionTier = 0;

                if (bits >= 10000) {
                    dropType = 'exploding';
                    baseRadius = MAX_RADIUS;
                    explosionTier = 1;
                    spawnEvent('exploding', username, baseRadius, 1, false, "", bitLabel);
                    return;
                } else if (bits >= 1000) {
                    dropType = 'exploding';
                    explosionTier = 0;

                    const progress = (bits - 1000) / (9999 - 1000);
                    const clamped = Math.max(0, Math.min(1, progress));
                    const debrisCount = 11 + Math.floor(clamped * 9);

                    const debrisRadius = 15 + Math.sqrt(99) * 2.5;

                    spawnEvent('exploding', username, baseRadius, 0, false, "", bitLabel, debrisCount, debrisRadius);
                    return;
                } else if (bits >= 100) {
                    dropType = 'cluster';

                    // --- TIER 2 LOGIC ---
                    const numBalls = 1 + Math.floor(bits / 100);
                    const clusterRadius = 15 + Math.sqrt(99) * 2.5;

                    for(let i=0; i < numBalls; i++) {
                        const currentLabel = (i === 0) ? bitLabel : "";
                        setTimeout(() => spawnEvent('normal', username, clusterRadius + Math.random() * 5, 0, false, "", currentLabel), i * 30);
                    }
                    return;
                } else {
                    dropType = 'normal';
                    spawnEvent(dropType, username, baseRadius, 0, false, "", bitLabel);
                    return;
                }

                if (dropType !== 'normal') spawnEvent(dropType, username, baseRadius, explosionTier);
            });

            // 3. CHAT COMMANDS
            if (client) client.on('Twitch.ChatMessage', (payload) => {
                const d = getSafeData(payload);
                const msg = d.message?.message || d.message || "";
                const username = getName(payload);

                if (msg.trim().toLowerCase() === "!flushpit") {
                    openPit();
                } else if (msg.trim().toLowerCase() === "!ball") {
                    const dropType = determineDropType();
                    const radius = 15 + Math.random() * 70;
                    spawnEvent(dropType, username, radius, 0, false, "", "!ball");
                }
            });

            // 4. CUSTOM EVENT
            if (client) client.on('General.Custom', (payload) => {
                const raw = JSON.stringify(payload);
                if (raw.includes("OpenPit")) openPit();
                if (raw.includes("SpawnBall")) spawnEvent('normal', "Streamer", 30);
            });

            // Expose for external calls
            window.spawnEvent = spawnEvent;
            window.openPit = openPit;

        })(); // End IIFE
    </script>
</body>
</html>